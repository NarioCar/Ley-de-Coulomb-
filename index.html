<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simulador Ley de Coulomb</title>
  <style>
    body { margin: 0; font-family: sans-serif; background: #f5f5f5; }
    canvas { display: block; background: #ffffff; margin: auto; border: 1px solid #ccc; }
    #info { text-align: center; margin: 10px; }
  </style>
</head>
<body>
  <div id="info">
    <p>Arrastra las cargas. Máximo 10 cargas. Valores en ±5μC. Fuerzas en N. Presiona "a" para agregar una carga.</p>
  </div>
  <canvas id="canvas" width="800" height="600"></canvas>
<div style="text-align:center; margin-top: 5px;">
  <button id="toggleGrid">Mostrar/Ocultar cuadriculado</button>
</div>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let showGrid = true;

    function drawGrid() {
      const spacing = 50; // 50 px = 0.5 m si scale = 1e-2
      ctx.strokeStyle = "#e0e0e0";
      ctx.lineWidth = 1;
      ctx.font = "10px sans-serif";
      ctx.fillStyle = "#999";
      ctx.textAlign = "left";

      for (let x = 0; x <= canvas.width; x += spacing) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
        ctx.fillText(`${(x * scale).toFixed(2)}m`, x + 2, 12);
      }
      for (let y = 0; y <= canvas.height; y += spacing) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
        ctx.fillText(`${(y * scale).toFixed(2)}m`, 2, y - 2);
      }
    }

    const k = 8.99e9; // N·m²/C²
    const scale = 1e-2; // 1px = 1cm = 0.01m
    const chargeValue = 5e-6; // 5 μC en Coulombs

    const charges = [
      { x: 200, y: 300, q: chargeValue },
      { x: 600, y: 300, q: -chargeValue }
    ];

    let selected = null;

    canvas.addEventListener("mousedown", e => {
      const { offsetX, offsetY } = e;
      for (let c of charges) {
        if (Math.hypot(c.x - offsetX, c.y - offsetY) < 15) {
          selected = c;
          break;
        }
      }
    });

    canvas.addEventListener("mouseup", () => selected = null);

    canvas.addEventListener("mousemove", e => {
      if (selected) {
        selected.x = e.offsetX;
        selected.y = e.offsetY;
        draw();
      }
    });

    document.getElementById("toggleGrid").addEventListener("click", () => {
      showGrid = !showGrid;
      draw();
    });

    function drawArrow(fromX, fromY, toX, toY, color = "red") {
      const headlen = 10;
      const dx = toX - fromX;
      const dy = toY - fromY;
      const angle = Math.atan2(dy, dx);
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
      ctx.lineTo(toX, toY);
      ctx.fillStyle = color;
      ctx.fill();
    }

    function computeForces() {
      const forces = charges.map(_ => ({ fx: 0, fy: 0 }));
      for (let i = 0; i < charges.length; i++) {
        for (let j = 0; j < charges.length; j++) {
          if (i === j) continue;
          const dx = (charges[j].x - charges[i].x) * scale;
          const dy = (charges[j].y - charges[i].y) * scale;
          const r2 = dx * dx + dy * dy;
          const r = Math.sqrt(r2);
          const forceMag = k * Math.abs(charges[i].q * charges[j].q) / r2;
          const sign = Math.sign(charges[i].q * charges[j].q) === 1 ? -1 : 1;
          const fx = sign * forceMag * dx / r;
          const fy = sign * forceMag * dy / r;
          forces[i].fx += fx;
          forces[i].fy += fy;
        }
      }
      return forces;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (showGrid) drawGrid();
      const forces = computeForces();

      for (let i = 0; i < charges.length; i++) {
        const c = charges[i];
        // Dibujar carga
        ctx.beginPath();
        ctx.arc(c.x, c.y, 15, 0, Math.PI * 2);
        ctx.fillStyle = c.q > 0 ? "red" : "blue";
        ctx.fill();
        ctx.strokeStyle = "black";
        ctx.stroke();
        // Texto de carga
        ctx.fillStyle = "white";
        ctx.font = "bold 10px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(c.q > 0 ? "+q" : "-q", c.x, c.y + 5);

        // Dibujar vector de fuerza
        const fx = forces[i].fx;
        const fy = forces[i].fy;
        const scaleVec = 1e3; // Reducida para evitar vectores demasiado grandes
        drawArrow(c.x, c.y, c.x + fx * scaleVec, c.y + fy * scaleVec);

        // Mostrar magnitud
        const fMag = Math.sqrt(fx * fx + fy * fy);
        ctx.fillStyle = "black";
        ctx.font = "12px sans-serif";
        ctx.fillText(`${fMag.toFixed(2)} N`, c.x + 30, c.y - 20);
      }
    }

    // Agrega hasta 10 cargas con valor fijo ±5μC alternando signo
    document.addEventListener("keydown", e => {
      if (e.key === "a" && charges.length < 10) {
        const sign = charges.length % 2 === 0 ? 1 : -1;
        charges.push({ x: 100 + charges.length * 50, y: 100, q: sign * chargeValue });
        draw();
      }
    });

    draw();
  </script>
</body>
</html>
